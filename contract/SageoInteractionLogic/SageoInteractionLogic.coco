coco SageoInteractionLogic

// interaction proof stored on-chain
class InteractionRecord:
    field interaction_id String
    field caller_sageo_id String
    field callee_sageo_id String
    field request_hash String
    field response_hash String
    field intent String
    field status_code I64
    field timestamp U64
    field a2a_context_id String
    field a2a_task_id String
    field a2a_message_id String
    field end_user_id String
    field end_user_session_id String

// cached stats per agent (Used for Return Type only, not in state)
class AgentInteractionStats:
    field total_requests_sent U64
    field total_requests_received U64
    field total_responses_sent U64
    field success_count U64
    field unique_counterparties U64
    field last_interaction_at U64

// minimal logic state for deployment initialization
state logic:
    deployed Bool

// per-agent state (Flattened stats)
state actor:
    agent_id String
    interaction_counter U64
    interactions []InteractionRecord
    counterparties []String
    
    // Flattened stats fields
    stats_total_requests_sent U64
    stats_total_requests_received U64
    stats_total_responses_sent U64
    stats_success_count U64
    stats_unique_counterparties U64
    stats_last_interaction_at U64

// runs once on deploy (initializes minimal logic state)
endpoint deploy dynamic Deploy():
    mutate true -> SageoInteractionLogic.Logic.deployed

// agents call this to join sageo before they can log interactions
// NOTE: Using invoke instead of enlist due to devnet limitation
endpoint dynamic Enlist(sageo_id String):
    mutate sageo_id -> SageoInteractionLogic.Sender.agent_id
    mutate 0 -> SageoInteractionLogic.Sender.interaction_counter
    mutate 0 -> SageoInteractionLogic.Sender.stats_total_requests_sent
    mutate 0 -> SageoInteractionLogic.Sender.stats_total_requests_received
    mutate 0 -> SageoInteractionLogic.Sender.stats_total_responses_sent
    mutate 0 -> SageoInteractionLogic.Sender.stats_success_count
    mutate 0 -> SageoInteractionLogic.Sender.stats_unique_counterparties
    mutate 0 -> SageoInteractionLogic.Sender.stats_last_interaction_at

// Logs an interaction request (sent or received)
// If interaction_id is empty, generates a new one (first call by initiator)
// If interaction_id is provided, uses that ID (subsequent calls by receiver)
endpoint dynamic LogRequest(
    interaction_id String,
    counterparty_sageo_id String,
    is_sender Bool,
    request_hash String,
    intent String,
    timestamp U64,
    a2a_context_id String,
    a2a_task_id String,
    a2a_message_id String,
    end_user_id String,
    end_user_session_id String
) -> (result_interaction_id String):
    // Check sender is enlisted
    memory my_sageo_id String
    observe agent_id <- SageoInteractionLogic.Sender.agent_id:
        if agent_id == "":
            throw "Agent not enlisted"
        my_sageo_id = agent_id

    // Generate or use provided interaction_id
    memory final_id String
    if interaction_id == "":
        // First call - generate new ID
        mutate counter <- SageoInteractionLogic.Sender.interaction_counter:
            counter += 1
            final_id = "ix_" + my_sageo_id + "_" + String(counter)
    else:
        // Subsequent call - use provided ID
        final_id = interaction_id

    // Build the record
    memory record InteractionRecord
    record.interaction_id = final_id
    if is_sender:
        record.caller_sageo_id = my_sageo_id
        record.callee_sageo_id = counterparty_sageo_id
    else:
        record.caller_sageo_id = counterparty_sageo_id
        record.callee_sageo_id = my_sageo_id
    record.request_hash = request_hash
    record.response_hash = ""
    record.intent = intent
    record.status_code = -1
    record.timestamp = timestamp
    record.a2a_context_id = a2a_context_id
    record.a2a_task_id = a2a_task_id
    record.a2a_message_id = a2a_message_id
    record.end_user_id = end_user_id
    record.end_user_session_id = end_user_session_id

    // Store interaction in Sender's state
    mutate interactions <- SageoInteractionLogic.Sender.interactions:
        disperse append(interactions, record)

    // Update stats
    if is_sender:
        mutate s_sent <- SageoInteractionLogic.Sender.stats_total_requests_sent:
            s_sent += 1
    else:
        mutate s_recv <- SageoInteractionLogic.Sender.stats_total_requests_received:
            s_recv += 1
    
    mutate s_last <- SageoInteractionLogic.Sender.stats_last_interaction_at:
        s_last = timestamp

    // Track unique counterparties
    memory is_new_counterparty Bool = true
    observe cp_list <- SageoInteractionLogic.Sender.counterparties:
        for i in range(len(cp_list)):
            if cp_list[i] == counterparty_sageo_id:
                is_new_counterparty = false
    
    if is_new_counterparty:
        mutate counterparties <- SageoInteractionLogic.Sender.counterparties:
            append(counterparties, counterparty_sageo_id)
        mutate s_unique <- SageoInteractionLogic.Sender.stats_unique_counterparties:
            s_unique += 1

    // Return the interaction ID
    result_interaction_id = final_id

// Logs a response (sent or received)
// Updates the existing interaction record with response details
endpoint dynamic LogResponse(
    interaction_id String,
    counterparty_sageo_id String,
    is_sender Bool,
    response_hash String,
    status_code I64,
    timestamp U64
):
    // Check agent is enlisted
    memory my_sageo_id String
    observe agent_id <- SageoInteractionLogic.Sender.agent_id:
        if agent_id == "":
            throw "Agent not enlisted"
        my_sageo_id = agent_id

    // Find and update the interaction record
    memory was_found Bool = false
    mutate interactions <- SageoInteractionLogic.Sender.interactions:
        for i in range(len(interactions)):
            if interactions[i].interaction_id == interaction_id:
                interactions[i].response_hash = response_hash
                interactions[i].status_code = status_code
                was_found = true
    
    if !was_found:
        throw "Interaction not found in state"

    // Update stats
    if is_sender:
        mutate s_sent <- SageoInteractionLogic.Sender.stats_total_responses_sent:
            s_sent += 1
    
    mutate s_last <- SageoInteractionLogic.Sender.stats_last_interaction_at:
        s_last = timestamp
    
    if status_code >= 200 && status_code < 300:
        mutate s_success <- SageoInteractionLogic.Sender.stats_success_count:
            s_success += 1

// lookup a single interaction by id (Dynamic to bypass devnet read-only limitation)
endpoint static GetInteraction(
    agent_identifier Identifier,
    ix_id String
) -> (record InteractionRecord, found Bool):
    memory result InteractionRecord
    memory was_found Bool = false
    observe interactions <- SageoInteractionLogic.Actor(agent_identifier).interactions:
        for i in range(len(interactions)):
            if interactions[i].interaction_id == ix_id:
                was_found = true
                // Manual copy to ensure safety (though dynamic allows storage access)
                result.interaction_id = interactions[i].interaction_id
                result.caller_sageo_id = interactions[i].caller_sageo_id
                result.callee_sageo_id = interactions[i].callee_sageo_id
                result.request_hash = interactions[i].request_hash
                result.response_hash = interactions[i].response_hash
                result.intent = interactions[i].intent
                result.status_code = interactions[i].status_code
                result.timestamp = interactions[i].timestamp
                result.a2a_context_id = interactions[i].a2a_context_id
                result.a2a_task_id = interactions[i].a2a_task_id
                result.a2a_message_id = interactions[i].a2a_message_id
                result.end_user_id = interactions[i].end_user_id
                result.end_user_session_id = interactions[i].end_user_session_id

    record = result
    found = was_found

// get paginated interactions for an agent (newest first)
endpoint static ListInteractionsByAgent(
    agent_identifier Identifier,
    limit U64,
    offset U64
) -> (records []InteractionRecord, total U64):
    memory result_records []InteractionRecord
    memory total_count U64 = 0
    observe interactions <- SageoInteractionLogic.Actor(agent_identifier).interactions:
        total_count = U64(len(interactions))

    if offset >= total_count:
        records = result_records
        total = total_count
        return

    memory count U64 = total_count - offset
    if count > limit:
        count = limit

    observe interactions <- SageoInteractionLogic.Actor(agent_identifier).interactions:
        for i in range(count):
            memory idx U64 = total_count - offset - 1 - i
            memory rec InteractionRecord
            rec.interaction_id = interactions[idx].interaction_id
            rec.caller_sageo_id = interactions[idx].caller_sageo_id
            rec.callee_sageo_id = interactions[idx].callee_sageo_id
            rec.request_hash = interactions[idx].request_hash
            rec.response_hash = interactions[idx].response_hash
            rec.intent = interactions[idx].intent
            rec.status_code = interactions[idx].status_code
            rec.timestamp = interactions[idx].timestamp
            rec.a2a_context_id = interactions[idx].a2a_context_id
            rec.a2a_task_id = interactions[idx].a2a_task_id
            rec.a2a_message_id = interactions[idx].a2a_message_id
            rec.end_user_id = interactions[idx].end_user_id
            rec.end_user_session_id = interactions[idx].end_user_session_id
            append(result_records, rec)

    records = result_records
    total = total_count

// get an agent's cached stats
endpoint static GetAgentInteractionStats(
    agent_identifier Identifier
) -> (stats AgentInteractionStats, found Bool):
    memory result AgentInteractionStats
    memory was_found Bool = false
    observe agent_id <- SageoInteractionLogic.Actor(agent_identifier).agent_id:
        was_found = agent_id != ""
    if was_found:
        observe s_sent <- SageoInteractionLogic.Actor(agent_identifier).stats_total_requests_sent:
            result.total_requests_sent = s_sent
        observe s_recv <- SageoInteractionLogic.Actor(agent_identifier).stats_total_requests_received:
            result.total_requests_received = s_recv
        observe s_resp <- SageoInteractionLogic.Actor(agent_identifier).stats_total_responses_sent:
            result.total_responses_sent = s_resp
        observe s_succ <- SageoInteractionLogic.Actor(agent_identifier).stats_success_count:
            result.success_count = s_succ
        observe s_uniq <- SageoInteractionLogic.Actor(agent_identifier).stats_unique_counterparties:
            result.unique_counterparties = s_uniq
        observe s_last <- SageoInteractionLogic.Actor(agent_identifier).stats_last_interaction_at:
            result.last_interaction_at = s_last
            
    stats = result
    found = was_found
