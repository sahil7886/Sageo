coco SageoLogicMinimal

// Test contract - adding full nested structures to test deployment

// Full AgentSkill from SageoIdentityLogic
class AgentSkill:
    field id String
    field name String
    field description String
    field tags String
    field examples String
    field input_modes String
    field output_modes String

// Full AgentCapabilities from SageoIdentityLogic
class AgentCapabilities:
    field streaming Bool
    field push_notifications Bool
    field state_transition_history Bool

// Full AgentCard from SageoIdentityLogic
class AgentCard:
    field name String
    field description String
    field version String
    field url String
    field protocol_version String
    field default_input_modes String
    field default_output_modes String
    field capabilities AgentCapabilities
    field skills []AgentSkill
    field icon_url String
    field documentation_url String
    field preferred_transport String

// Full AgentProfile from SageoIdentityLogic
class AgentProfile:
    field sageo_id String
    field owner String
    field wallet_address String
    field status String
    field created_at U64
    field updated_at U64
    field agent_card AgentCard

// AgentProfileMeta - profile metadata WITHOUT agent_card
class AgentProfileMeta:
    field sageo_id String
    field owner String
    field wallet_address String
    field status String
    field created_at U64
    field updated_at U64

// AgentInteractionStats - cached stats per agent
class AgentInteractionStats:
    field total_requests_sent U64
    field total_requests_received U64
    field total_responses_sent U64
    field success_count U64
    field unique_counterparties U64
    field last_interaction_at U64

// Full InteractionRecord from SageoInteractionLogic
class InteractionRecord:
    field interaction_id String
    field caller_sageo_id String
    field callee_sageo_id String
    field request_hash String
    field response_hash String
    field intent String
    field status_code I64
    field timestamp U64
    field a2a_context_id String
    field a2a_task_id String
    field a2a_message_id String
    field end_user_id String
    field end_user_session_id String

state logic:
    agent_counter U64
    interaction_counter U64
    agents Map[String]AgentProfile
    agent_ids []String
    interactions Map[String]InteractionRecord
    interaction_ids []String

state actor:
    owned_agents []String
    is_enlisted Bool
    agent_id String
    agent_interactions []String
    counterparties []String
    stats_total_requests_sent U64
    stats_total_requests_received U64
    stats_total_responses_sent U64
    stats_success_count U64
    stats_unique_counterparties U64
    stats_last_interaction_at U64

endpoint deploy dynamic Deploy():
    mutate 0 -> SageoLogicMinimal.Logic.agent_counter
    mutate 0 -> SageoLogicMinimal.Logic.interaction_counter

endpoint dynamic Enlist():
    mutate true -> SageoLogicMinimal.Sender.is_enlisted

endpoint static GetAgentCount() -> (count U64):
    observe counter <- SageoLogicMinimal.Logic.agent_counter:
        count = counter

// Full RegisterAgent from SageoLogic
endpoint dynamic RegisterAgent(
    name String,
    description String,
    version String,
    url String,
    protocol_version String,
    default_input_modes String,
    default_output_modes String,
    streaming Bool,
    push_notifications Bool,
    state_transition_history Bool,
    icon_url String,
    documentation_url String,
    preferred_transport String,
    wallet_address String
) -> (sageo_id String):
    memory new_id String
    mutate counter <- SageoLogicMinimal.Logic.agent_counter:
        counter += 1
        new_id = "agent_" + String(counter)

    memory timestamp U64
    observe counter <- SageoLogicMinimal.Logic.agent_counter:
        timestamp = counter

    memory caps AgentCapabilities
    caps.streaming = streaming
    caps.push_notifications = push_notifications
    caps.state_transition_history = state_transition_history

    memory card AgentCard
    card.name = name
    card.description = description
    card.version = version
    card.url = url
    card.protocol_version = protocol_version
    card.default_input_modes = default_input_modes
    card.default_output_modes = default_output_modes
    card.capabilities = caps
    card.icon_url = icon_url
    card.documentation_url = documentation_url
    card.preferred_transport = preferred_transport

    memory new_profile AgentProfile
    new_profile.sageo_id = new_id
    new_profile.owner = "sender"
    new_profile.wallet_address = wallet_address
    new_profile.status = "ACTIVE"
    new_profile.created_at = timestamp
    new_profile.updated_at = timestamp
    new_profile.agent_card = card

    mutate agents <- SageoLogicMinimal.Logic.agents:
        disperse agents[new_id] <- new_profile

    mutate ids <- SageoLogicMinimal.Logic.agent_ids:
        append(ids, new_id)

    mutate owned <- SageoLogicMinimal.Sender.owned_agents:
        append(owned, new_id)

    mutate new_id -> SageoLogicMinimal.Sender.agent_id

    sageo_id = new_id

// Log a request from caller to callee
endpoint dynamic LogRequest(
    callee_identifier Identifier,
    request_hash String,
    intent String,
    timestamp U64,
    a2a_context_id String,
    a2a_task_id String,
    a2a_message_id String,
    end_user_id String,
    end_user_session_id String
) -> (interaction_id String):
    memory caller_sageo_id String
    observe agent_id <- SageoLogicMinimal.Sender.agent_id:
        if agent_id == "":
            throw "Caller agent_id not set"
        caller_sageo_id = agent_id

    memory callee_sageo_id String
    memory callee_enlisted Bool = false
    observe agent_id <- SageoLogicMinimal.Actor(callee_identifier).agent_id:
        if agent_id != "":
            callee_sageo_id = agent_id
            callee_enlisted = true
    if !callee_enlisted:
        throw "Callee agent_id not set"

    memory new_id String
    mutate counter <- SageoLogicMinimal.Logic.interaction_counter:
        counter += 1
        new_id = "ix_" + String(counter)

    memory record InteractionRecord
    record.interaction_id = new_id
    record.caller_sageo_id = caller_sageo_id
    record.callee_sageo_id = callee_sageo_id
    record.request_hash = request_hash
    record.response_hash = ""
    record.intent = intent
    record.status_code = -1
    record.timestamp = timestamp
    record.a2a_context_id = a2a_context_id
    record.a2a_task_id = a2a_task_id
    record.a2a_message_id = a2a_message_id
    record.end_user_id = end_user_id
    record.end_user_session_id = end_user_session_id

    mutate interactions <- SageoLogicMinimal.Logic.interactions:
        disperse interactions[new_id] <- record

    mutate ids <- SageoLogicMinimal.Logic.interaction_ids:
        append(ids, new_id)

    mutate caller_interactions <- SageoLogicMinimal.Sender.agent_interactions:
        append(caller_interactions, new_id)

    mutate s_sent <- SageoLogicMinimal.Sender.stats_total_requests_sent:
        s_sent += 1
    mutate s_last <- SageoLogicMinimal.Sender.stats_last_interaction_at:
        s_last = timestamp

    memory is_new_counterparty Bool = true
    observe cp_list <- SageoLogicMinimal.Sender.counterparties:
        for i in range(len(cp_list)):
            if cp_list[i] == callee_sageo_id:
                is_new_counterparty = false

    if is_new_counterparty:
        mutate caller_counterparties <- SageoLogicMinimal.Sender.counterparties:
            append(caller_counterparties, callee_sageo_id)
        mutate s_unique <- SageoLogicMinimal.Sender.stats_unique_counterparties:
            s_unique += 1

    mutate callee_interactions <- SageoLogicMinimal.Actor(callee_identifier).agent_interactions:
        append(callee_interactions, new_id)

    mutate c_recv <- SageoLogicMinimal.Actor(callee_identifier).stats_total_requests_received:
        c_recv += 1
    mutate c_last <- SageoLogicMinimal.Actor(callee_identifier).stats_last_interaction_at:
        c_last = timestamp

    memory is_new_counterparty_callee Bool = true
    observe cp_list_callee <- SageoLogicMinimal.Actor(callee_identifier).counterparties:
        for i in range(len(cp_list_callee)):
            if cp_list_callee[i] == caller_sageo_id:
                is_new_counterparty_callee = false

    if is_new_counterparty_callee:
        mutate callee_counterparties <- SageoLogicMinimal.Actor(callee_identifier).counterparties:
            append(callee_counterparties, caller_sageo_id)
        mutate c_unique <- SageoLogicMinimal.Actor(callee_identifier).stats_unique_counterparties:
            c_unique += 1

    interaction_id = new_id

// Complete an interaction with response
endpoint dynamic LogResponse(
    ix_id String,
    response_hash String,
    status_code I64,
    timestamp U64
) -> (record InteractionRecord):
    storage result InteractionRecord
    mutate interactions <- SageoLogicMinimal.Logic.interactions:
        if interactions[ix_id].interaction_id == "":
            throw "Interaction not found"
        interactions[ix_id].response_hash = response_hash
        interactions[ix_id].status_code = status_code
        result = interactions[ix_id]

    mutate s_sent <- SageoLogicMinimal.Sender.stats_total_responses_sent:
        s_sent += 1
    mutate s_last <- SageoLogicMinimal.Sender.stats_last_interaction_at:
        s_last = timestamp

    if status_code >= 200 && status_code < 300:
        mutate s_success <- SageoLogicMinimal.Sender.stats_success_count:
            s_success += 1

    record = result

// Get all agent IDs
endpoint static GetAllAgentIds() -> (ids []String):
    memory result []String
    observe agent_ids <- SageoLogicMinimal.Logic.agent_ids:
        for i in range(len(agent_ids)):
            append(result, agent_ids[i])
    ids = result

// Get paginated interactions for an agent (newest first)
endpoint dynamic ListInteractionsByAgent(
    agent_identifier Identifier,
    limit U64,
    offset U64
) -> (records []InteractionRecord, total U64):
    memory result_records []InteractionRecord
    memory total_count U64 = 0
    memory ids []String

    observe agent_ids <- SageoLogicMinimal.Actor(agent_identifier).agent_interactions:
        total_count = U64(len(agent_ids))
        for i in range(total_count):
            append(ids, agent_ids[i])

    if offset >= total_count:
        records = result_records
        total = total_count
        return

    memory count U64 = total_count - offset
    if count > limit:
        count = limit

    observe interactions <- SageoLogicMinimal.Logic.interactions:
        for i in range(count):
            memory idx U64 = total_count - offset - 1 - i
            memory id String = ids[idx]
            memory rec InteractionRecord
            rec.interaction_id = interactions[id].interaction_id
            rec.caller_sageo_id = interactions[id].caller_sageo_id
            rec.callee_sageo_id = interactions[id].callee_sageo_id
            rec.request_hash = interactions[id].request_hash
            rec.response_hash = interactions[id].response_hash
            rec.intent = interactions[id].intent
            rec.status_code = interactions[id].status_code
            rec.timestamp = interactions[id].timestamp
            rec.a2a_context_id = interactions[id].a2a_context_id
            rec.a2a_task_id = interactions[id].a2a_task_id
            rec.a2a_message_id = interactions[id].a2a_message_id
            rec.end_user_id = interactions[id].end_user_id
            rec.end_user_session_id = interactions[id].end_user_session_id
            append(result_records, rec)

    records = result_records
    total = total_count

// Get paginated recent interactions (newest first)
endpoint dynamic ListRecentInteractions(
    limit U64,
    offset U64
) -> (records []InteractionRecord, total U64):
    memory result_records []InteractionRecord
    memory total_count U64 = 0
    memory ids []String

    observe all_ids <- SageoLogicMinimal.Logic.interaction_ids:
        total_count = U64(len(all_ids))
        for i in range(total_count):
            append(ids, all_ids[i])

    if offset >= total_count:
        records = result_records
        total = total_count
        return

    memory count U64 = total_count - offset
    if count > limit:
        count = limit

    observe interactions <- SageoLogicMinimal.Logic.interactions:
        for i in range(count):
            memory idx U64 = total_count - offset - 1 - i
            memory id String = ids[idx]
            memory rec InteractionRecord
            rec.interaction_id = interactions[id].interaction_id
            rec.caller_sageo_id = interactions[id].caller_sageo_id
            rec.callee_sageo_id = interactions[id].callee_sageo_id
            rec.request_hash = interactions[id].request_hash
            rec.response_hash = interactions[id].response_hash
            rec.intent = interactions[id].intent
            rec.status_code = interactions[id].status_code
            rec.timestamp = interactions[id].timestamp
            rec.a2a_context_id = interactions[id].a2a_context_id
            rec.a2a_task_id = interactions[id].a2a_task_id
            rec.a2a_message_id = interactions[id].a2a_message_id
            rec.end_user_id = interactions[id].end_user_id
            rec.end_user_session_id = interactions[id].end_user_session_id
            append(result_records, rec)

    records = result_records
    total = total_count
